import itertools
import sbol


# ------------------------------------------------------------
# Component Methods

def c_getDefinition(self):
    return self.doc.getComponentDefinition(self.definition)


sbol.Component.getDefinition = c_getDefinition


# ------------------------------------------------------------
# SequenceAnnotation Methods

# TODO: is the parent always a component definition? Do we have to
# handle the case where the parent is a module definition?
def sa_getParent(self):
    return self.doc.getComponentDefinition(self.parent.identity)


sbol.SequenceAnnotation.getParent = sa_getParent


def sa_getComponent(self):
    return self.getParent().getComponent(self.component)


sbol.SequenceAnnotation.getComponent = sa_getComponent


def sa_getComponentDefinition(self):
    return self.getComponent().getDefinition()


sbol.SequenceAnnotation.getComponentDefinition = sa_getComponentDefinition


def sa_getRanges(self):
    for loc in self.locations:
        r = self.locations[loc.identity]
        if isinstance(r, sbol.Range):
            yield r


sbol.SequenceAnnotation.getRanges = sa_getRanges


# ------------------------------------------------------------
# ComponentDefinition Methods

def cd_insert(self, cd_to_insert, insert_point, name_of_cd):
    """Constuct SBOL representing a genetic insert. Inserts cd_to_insert
    into self at insert_point.

    This method constructs a new ComponentDefinition that is annotated
    with the original sequence and the inserted sequence such that the
    new DNA sequence can be generated. This method does not generate
    the new sequence itself.

    The new sequence is not generated to avoid duplicating very long
    sequences in memory when they are not needed.

    """

    # print('{} will insert {} at {}'.format(self, cd_to_insert, insert_point))
    # Make a new CD to represent the new sequence

    orig_len = len(self.sequence.elements)
    # print('Original length = {}'.format(orig_len))
    insert_len = len(cd_to_insert.sequence.elements)
    # print('Insertion length = {}'.format(insert_len))

    # Keep insert_point in bounds
    if insert_point < 1:
        insert_point = 1
    if insert_point > orig_len + 1:
        insert_point = orig_len + 1

    cd = sbol.ComponentDefinition(name_of_cd)
    sa = cd.sequenceAnnotations.create('orig_sa')
    if insert_point > 1:
        # If insert point is not at the beginning, construct a range
        # that precedes the insert point.
        range1 = sa.locations.createRange('orig_r1')
        range1.start = 1
        range1.end = insert_point - 1
    range2 = sa.locations.createRange('orig_r2')
    range2.start = insert_point + insert_len
    range2.end = orig_len + insert_len

    # Now link myself into the structure of the new
    # ComponentDefinition
    self_comp = cd.components.create('orig_comp')
    self_comp.definition = self
    sa.component = self_comp

    # Now link the insert to the new cd
    insert_comp = cd.components.create('insert_comp')
    insert_comp.definition = cd_to_insert
    insert_sa = cd.sequenceAnnotations.create('insert_sa')
    insert_sa.component = insert_comp

    # Add the range to the insert_sa
    insert_range = insert_sa.locations.createRange('insert_range')
    insert_range.start = insert_point
    insert_range.end = insert_point + insert_len - 1

    self.doc.addComponentDefinition(cd)

    return cd


# Monkey patch the insert method for now. It will go in the swig wrapper later.
sbol.ComponentDefinition.insert = cd_insert


def cd_getComponent(self, uri):
    for c in self.components:
        if c.identity == uri:
            return c
    return None


sbol.ComponentDefinition.getComponent = cd_getComponent


class InsertionError(Exception):
    pass


sbol.InsertionError = InsertionError


# From https://docs.python.org/3.6/library/itertools.html#recipes
def pairwise(iterable):
    "s -> (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)


def cd_compileInsert(self):
    """Compiles a genetic insert by parsing the SBOL and constructing the
    sequence.

    The layout of self is expected to match the SBOL generated by
    ComponentDefinition.insert().

    """
    #  Self must not already have a sequence
    #     We could also allow self to have a sequence and simply
    #     return so we don't overwrite the sequence.
    if self.sequence is not None:
        raise InsertionError('A sequence already exists.')

    #  There must be at least two annotations
    if len(self.sequenceAnnotations) < 2:
        raise InsertionError('Not enough sequence annotations, need at least 2.')

    #  Two annotations must have a component and have at least one location
    annotations = [a for a in self.sequenceAnnotations
                   if a.component is not None and len(a.locations) > 0]
    if len(annotations) < 2:
        raise InsertionError('Not enough annotations, need at least 2 with a component and a location.')

    # There must be two annotations that have CDs that have non-empty sequences
    annotations = [a for a in annotations if a.getComponentDefinition().sequence.elements]
    if len(annotations) < 2:
        raise InsertionError('Not enough linked ComponentDefinitions have sequences.')

    # Build a list of tuples. Each tuple is (Range, string), with the
    # string containing a substring of the CD's original
    # sequence. These strings are later joined to create the final
    # sequence with insertion.
    ranges = []
    for a in annotations:
        seq = a.getComponentDefinition().sequence.elements
        # for r in a.getRanges():
        #     ranges.append((r, seq))
        aranges = list(a.getRanges())
        # We really need to do some work here....
        # We need to verify that the ranges cover the entire sequence,
        if sum([r.length() for r in aranges]) != len(seq):
            msg = 'Insufficient ranges for sequence {}: {}'
            raise InsertionError(msg.format(seq, ['Range({}, {})'.format(r.start, r.end) for r in aranges]))
        # and we should break up the sequence now, while we have the information, to match
        # the ranges. Then all we have to do later is append the strings.
        for r in aranges:
            ranges.append((r, seq[:r.length()]))
            seq = seq[r.length():]

    # Sort the list of tuples by Range start, then end
    ranges.sort(key=lambda tup: (tup[0].start, tup[0].end))

    # Verify that the ranges are in proper order, have not gaps and no overlaps.
    for rs1, rs2 in pairwise(ranges):
        r1 = rs1[0]
        r2 = rs2[0]
        # print('R({}, {}) <==> R({}, {})'.format(r1.start, r1.end, r2.start, r2.end))
        if not r1.adjoins(r2):
            raise InsertionError('Ranges are not contiguous')
        if not r1.precedes(r2):
            raise InsertionError('Sorting ranges has failed')
        if r1.overlaps(r2):
            raise InsertionError('Ranges overlap')

    # Everything looks good, create the final sequence
    new_seq = ''.join([tup[1] for tup in ranges])
    # Now construct the SBOL object(s) to represent this sequence
    self.sequence = sbol.Sequence('new_seq', new_seq)


sbol.ComponentDefinition.compileInsert = cd_compileInsert


# ------------------------------------------------------------
# Initial testing is below here.

# Set up the test case
# sbol.setHomespace('https://example.com')
# def makeInsert(dst_seq, insert_seq, insert_loc):
#     doc = sbol.Document()
#     cd0 = sbol.ComponentDefinition('wt_cd')
#     cd0.sequence = sbol.Sequence('wt_seq')
#     cd0.sequence.elements = dst_seq
#     doc.addComponentDefinition(cd0)

#     insert_cd = sbol.ComponentDefinition('insert_cd')
#     insert_cd.sequence = sbol.Sequence('insert_seq')
#     insert_cd.sequence.elements = insert_seq
#     doc.addComponentDefinition(insert_cd)

#     cd = cd0.insert(insert_cd, insert_loc, 'new_cd')
#     return (doc, cd.identity)

# doc = sbol.Document()
# cd0 = sbol.ComponentDefinition('wt_cd')
# cd0.sequence = sbol.Sequence('wt_seq')
# cd0.sequence.elements = 'atcg'
# doc.addComponentDefinition(cd0)

# insert_cd = sbol.ComponentDefinition('insert_cd')
# insert_cd.sequence = sbol.Sequence('insert_seq')
# insert_cd.sequence.elements = 'aa'
# doc.addComponentDefinition(insert_cd)

# cd = cd0.insert(insert_cd, 3, 'new_cd')
# doc, uri = makeInsert('atcg', 'aa', 3)
# cd = doc.getComponentDefinition(uri)

# Checking our answer...
# for sa in cd.sequenceAnnotations:
#     for l in sa.locations:
#         l2 = cd.sequenceAnnotations[sa.displayId].locations[l.displayId]
#         print('Range {}: {} -> {}'.format(l.displayId, l2.start, l2.end))

# cd.compileInsert()
# print('cd.sequence.elements =', cd.sequence.elements)
# doc.write('sbol.xml')
