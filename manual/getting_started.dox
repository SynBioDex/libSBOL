//////////////////////////////////////////////////////////////////////
/// @page getting_started
/// @section getting_started Getting Started
///
/// This beginnerâ€™s guide will help you quickly set up a client project and introduces the basic principles of libSBOL for new users. This guide is not meant to be a comprehensive documentation of the library or the SBOL standard.  Refer to the [specification document](http://sbolstandard.org/downloads/specifications/specification-data-model-2-0-1/) for a complete description of all SBOL data objects and their properties.
///
/// The libSBOL repository contains example Xcode and Visual Studio project files.  You can open these project files in your preferred IDE. The projects assume that you have already run `make install` (see @ref mainpage for build instructions) and that libSBOL has been installed to your system's standard library path. 
///
/// If you have installed libSBOL to a custom location and you would like to configure your Xcode project to link your local build, then you will have to configure the Build Settings.  Under Search Paths specify the Library and Header Search Paths to your local build.  Under Linking, Other Linker Flags, specify "-lsbol -lraptor2 -lxml2 -liconv -lz"
///
/// @section document Creating an SBOL Document
///
/// An SBOLDocument object is a container for SBOL data objects. All file I/O operations are performed on the Document object. Usually the first step is to create an SBOLDocument in which to put your objects. This can be done by calling the SBOLDocument constructor.  The read and write methods are used for 
/// ```
/// Document& doc = *new Document();
/// doc.read("CRISPR_example.xml")
/// doc.write("CRISPR_example.xml")
/// ```
/// Experienced C++ programmers may find that returning a reference from a new operator is an unusual idiomatic choice.  See @ref idiomatic_cpp for a discussion about this stylistic preference in this tutorial.
///
/// @section creating_objects Creating SBOL Data Objects
///
/// Both structural and functional details of biological designs can be described with SBOL data objects.  The principle classes for describing the structure and primary sequence of a design are ComponentDefinitions, Components, and Sequences, SequenceAnnotations.  The principle classes for describing the function of a design are ModuleDefinitions, Modules, and Interactions. These classes and their properties are represented as Unified Modeling Language (UML) diagrams in the specification document.  For example, following is the diagram for a ComponentDefinition which will be referred to in later sections.
/// ![](component_definition_uml.png) 
/// Objects can be created by calling their respective constructors. Each new object must be assigned a unique identity, or uniform resource identifier (URI), and each constructor has two alternative signatures.  One signature accepts a raw URI, while the "compliant" constructor auto-constructs a URI.
///
/// The following constructs a ModuleDefinition given a raw URI:
/// ```
/// ModuleDefinition& CRISPRTemplate = *new ModuleDefinition("sys-bio.org/CRISPRTemplate");
/// ```
///
/// The following auto-constructs a compliant URI from an authority, a displayID, and a version number:
/// ```
/// ModuleDefinition& CRISPRTemplate = *new ModuleDefinition("sys-bio.org", "CRISPRTemplate", "1.0.0");
/// ```
/// The identity of the new object is thus assigned as "sys-bio.org/ModuleDefinition/CRISPRTemplate/1.0.0"
///
/// Some constructors have required fields. In the specification document, required fields are indicated as properties with a cardinality of 1 or more.  For example, a ComponentDefinition (see the UML diagram above) has only one required field, the type, which specifies the molecular type of a component. Required fields MUST be specified when calling a constructor.  The following creates a protein component.
/// 
/// ```
/// ComponentDefinition& Cas9 = *new ComponentDefinition("sys-bio.org", "Cas9", "1.0.0", BIOPAX_PROTEIN);
/// ```
/// Notice the type is specified using a predefined constant.  See @ref constants.h for all such predefined constants.
///
/// @section adding_objects Adding Objects to a Document
///
/// In some cases a developer may want to use SBOL objects as intermediate data structures in a computational biology workflow.  In this case the user is free to manipulate objects independently of a Document.  However, if the user wishes to write out a file with all the information contained in their object, they must first add it to the Document.  This is done using a templated add method.
/// ```
/// doc.add<ModuleDefinition>(CRISPRTemplate);
/// doc.add<ComponentDefinition>(Cas9);
/// ``` 
/// @section optional_fields Setting and Editing Optional Fields
///
/// Objects may also include optional fields.  These are indicated in UML as properties having a cardinality of 0 or more.  All properties of a ComponentDefinition are optional, except for the type.  Optional properties can only be set after the object is created. The following code creates a DNA component which is designated as a promoter: 
/// ```
/// ComponentDefinition& TargetPromoter = *new ComponentDefinition("sys-bio.org", "TargetPromoter", "1.0.0", BIOPAX_DNA);
/// TargetPromoter.roles.set(SO_PROMOTER)
/// ```
///
/// All properties have a set and a get method. To view the value of a property:
/// ```
/// cout << TargetPromoter.roles.get() << endl;
/// ```
/// This returns the string "http://identifiers.org/so/SO:0000167" which is the Sequence Ontology term for a promoter.
///
/// Note also that some properties support a list of values.  A property with a cardinality indicated by an asterisk symbol indicates that the property may hold an arbitrary number of values.  For example, a ComponentDefinition may be assigned multiple roles.  To add a new role:
/// ```
/// TargetPromoter.roles.add(SO "0000568");
/// ```
///
/// @section child_objects Creating and Editing Child Objects
///
/// Some SBOL objects can be composed into hierarchical parent-child relationships.  In the specification diagrams, these relationshipss are indicated by black diamond arrows.  In the UML diagram above, the black diamond indicates that ComponentDefinitions are parents of SequenceAnnotations.  Properties of this type can be modified using the add method and passing the child object as the argument.
/// ```
/// TargetPromoter.annotations.add(annotation_object)
/// ```
/// @section references Creating and Editing Reference Properties
///
/// Some SBOL objects point to other objects by way of references. For example, ComponentDefinitions point to their corresponding Sequences. Properties of this type should be set with the URI of the related object. 
/// ``` 
/// ComponentDefinition& EYFPGene = *new ComponentDefinition(BASE_URI, "EYFPGene", v, BIOPAX_DNA);
/// Sequence& seq = *new Sequence(BASE_URI, "EYFPSequence", "1.0.0", "atgnnntaa", SBOL_ENCODING_IUPAC);
/// EYFPGene.sequence.setReference(BASE_URI, "EYFPSequence, "1.0.0");
/// ```
/// The setReference method automatically constructs a complicant URI.  Another way to set the reference is to specify the full URI.
/// ```
/// EYFPGene.sequence.set(seq.identity.get());
/// ```
/// @section lists_of_objects Iterating and Indexing Lists
/// Some properties can contain multiple values or objects. As mentioned under @ref optional_fields additional values can be specified with the add method.  In addition you may iterate over lists of objects or values.
/// ```
/// // Iterate through objects (black diamond properties in UML)
/// for( auto i_p = Cas9ComplexFormation.participations.begin(); i_p != Cas9ComplexFormation.participations.end(); i_p++)
/// {
///     Participation& p = (*i_p);
///     cout << p.identity.get() << endl;
///     cout << p.roles.get() << endl;
/// }
///   
/// // Iterate through references (white diamond properties in UML)
/// for (auto i_role = reaction_participant.roles.begin(); i_role != reaction_participant.roles.end(); i_role++)
/// {
///     string role = *i_role;
///     cout << role << endl;
/// }
/// ```
/// Numerical indexing of lists works as well:
/// ```
/// cout << Cas9ComplexFormation.participations[0].identity.get() << endl;
/// ```
/// @section idiomatic_cpp A Note on our Idiomatic Use of References
///
/// In C++ creating a reference to an object using the new operator is a matter of stylistic controversy. For one thing, mixing references with the new operator can make low level memory management confusing for some developers.  The reason this isn't an issue here is because libSBOL encapsulates memory management within the Document object. Pointers to all the objects in a Document are freed when the Document destructor is called.  Coming from a Python background to C++, we wanted to maximize the object-oriented experience using the library and the reference syntax feels and looks more object-oriented. Rest assured however, that if you disagree with this idiomatic style, you can still work with pointers in the more traditional way.
//////////////////////////////////////////////////////////////////////
